<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Lab - Physics Puzzle | LIPA Studios</title>
    <meta name="description" content="Solve physics puzzles in a cyberpunk laboratory! Manipulate objects, master gravity, and complete experiments.">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-633RQLC6T0"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-633RQLC6T0');
    </script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Orbitron', monospace; background: linear-gradient(135deg, #050505 0%, #0a0a0a 50%, #1a0a1a 100%); color: #00FFFF; overflow: hidden; height: 100vh; user-select: none; }
        .game-container { width: 100%; height: 100vh; display: flex; flex-direction: column; position: relative; }
        .header { height: 60px; background: rgba(0,0,0,0.8); border-bottom: 2px solid #FF0080; display: flex; justify-content: space-between; align-items: center; padding: 0 20px; z-index: 100; }
        .header h1 { color: #39FF14; font-size: 24px; font-weight: 700; text-shadow: 0 0 10px #39FF14; letter-spacing: 2px; }
        .level-info { display: flex; gap: 20px; align-items: center; }
        .level-number { color: #FFFF00; font-weight: 700; font-size: 18px; text-shadow: 0 0 8px #FFFF00; }
        .lab-area { flex: 1; position: relative; background: radial-gradient(circle at 20% 80%, rgba(255,0,128,0.1) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(0,255,255,0.1) 0%, transparent 50%), linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%); overflow: hidden; }
        .lab-grid { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(0,255,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,255,0.1) 1px, transparent 1px); background-size: 40px 40px; pointer-events: none; }
        #gameCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; cursor: grab; will-change: transform; }
        #gameCanvas:active { cursor: grabbing; }
        .controls { height: 80px; background: rgba(0,0,0,0.9); border-top: 2px solid #00FFFF; display: flex; justify-content: center; align-items: center; gap: 15px; padding: 10px; }
        .btn { padding: 12px 20px; border: none; border-radius: 8px; font-family: 'Orbitron', monospace; font-weight: 700; font-size: 14px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 0 15px rgba(255,255,255,0.1); min-width: 80px; }
        .btn-primary { background: linear-gradient(45deg, #FF0080, #FF6600); color: white; text-shadow: 0 0 5px rgba(255,255,255,0.8); }
        .btn-secondary { background: linear-gradient(45deg, #00FFFF, #39FF14); color: #000; text-shadow: none; }
        .btn-reset { background: linear-gradient(45deg, #666, #999); color: white; }
        .btn:hover { transform: scale(1.05); box-shadow: 0 0 25px rgba(255,255,255,0.3); }
        .success-explosion { position: absolute; width: 100px; height: 100px; border-radius: 50%; background: radial-gradient(circle, rgba(57,255,20,0.8) 0%, transparent 70%); animation: successBlast 0.6s ease-out forwards; pointer-events: none; z-index: 100; }
        @keyframes successBlast { 0% { transform: scale(0); opacity: 1; } 100% { transform: scale(4); opacity: 0; } }
        @media (max-width: 768px) { .header h1 { font-size: 18px; } .btn { padding: 8px 12px; font-size: 12px; min-width: 60px; } }
    </style>
</head>
<body>
    <!-- AdSense Banner -->
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4129506161314540" data-ad-slot="auto" data-ad-format="auto"></ins>
    
    <div class="game-container">
        <header class="header">
            <h1>üß™ NEON LAB</h1>
            <div class="level-info">
                <div class="level-number" id="levelDisplay">LEVEL 1</div>
                <div id="starsDisplay">‚≠ê‚≠ê‚≠ê</div>
            </div>
        </header>
        
        <div class="lab-area">
            <div class="lab-grid"></div>
            <canvas id="gameCanvas"></canvas>
        <div class="instructions" style="background: rgba(0,0,0,0.95); color: #00FFFF; padding: 15px; text-align: center; border-bottom: 2px solid #FF0080; font-size: 16px; font-weight: 700;">
            <div id="instructionText">üéØ OBJETIVO: 1Ô∏è‚É£ Arrastra objetos 2Ô∏è‚É£ DOBLE TAP para rotar 3Ô∏è‚É£ Presiona TEST 4Ô∏è‚É£ Part√≠cula rebota hasta el cuadro verde ‚úÖ</div>
        </div>        </div>
        
        <div class="controls">
            <button class="btn btn-reset" onclick="resetLevel()">üîÑ RESET</button>
            <button class="btn btn-primary" onclick="launchParticle()">üöÄ TEST</button>
            <button class="btn btn-secondary" onclick="nextLevel()">‚û°Ô∏è NEXT</button>
            <button class="btn btn-reset" onclick="showTutorial()">‚ùì HELP</button>
        </div>
    </div>
    
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        
        let gameState = { currentLevel: 1, gameActive: false, draggedObject: null, dragOffset: { x: 0, y: 0 }, objects: [], particle: null, particleLauncher: null, collectionChamber: null, levelComplete: false };
        let isDragging = false;
        let lastTapTime = 0;
        let tapTarget = null;        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
        
        class PhysicsObject {
            constructor(type, x, y, width, height, properties = {}) {
                this.type = type; this.x = x; this.y = y; this.width = width; this.height = height;
                this.rotation = properties.rotation || 0; this.mass = properties.mass || 1;
                this.color = properties.color || '#FF0080'; this.draggable = properties.draggable !== false; this.rotation = properties.rotation || 0;
                this.isStatic = properties.isStatic || false;
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                ctx.shadowColor = this.color; ctx.shadowBlur = 15;
                
                switch(this.type) {
                    case 'ramp':
                        const gradient1 = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                        gradient1.addColorStop(0, '#FF0080'); gradient1.addColorStop(1, '#FF6600');
                        ctx.fillStyle = gradient1; ctx.strokeStyle = '#FF0080'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(-this.width/2, this.height/2); ctx.lineTo(this.width/2, this.height/2); ctx.lineTo(this.width/2, -this.height/2); ctx.closePath(); ctx.fill(); ctx.stroke();
                        break;
                    case 'block':
                        const gradient2 = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                        gradient2.addColorStop(0, '#666'); gradient2.addColorStop(1, '#999');
                        ctx.fillStyle = gradient2; ctx.strokeStyle = '#999'; ctx.lineWidth = 2;
                        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height); ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                        break;
                    case 'bouncy-pad':
                        const gradient3 = ctx.createRadialGradient(0, 0, 0, 0, 0, this.width/2);
                        gradient3.addColorStop(0, '#39FF14'); gradient3.addColorStop(1, '#00FFFF');
                        ctx.fillStyle = gradient3; ctx.strokeStyle = '#39FF14'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(0, 0, this.width/2, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        break;
                    case 'launcher':
                        ctx.fillStyle = '#FFFF00'; ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.arc(0, 0, this.width/2, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                        break;
                    case 'chamber':
                        ctx.fillStyle = '#39FF14'; ctx.strokeStyle = '#39FF14'; ctx.lineWidth = 3;
                        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height); ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                        break;
                }
                ctx.restore();
            }
            
            contains(x, y) { return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height; }
        }
        
        class Particle {
            constructor(x, y) { 
                this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.radius = 6; 
                this.active = true; this.trail = []; this.bounces = 0;
            }
            
            update(deltaTime) {
                if (!this.active) return;
                
                // Apply gravity
                this.vy += 300 * deltaTime;
                
                // Store old position for collision detection
                const oldX = this.x, oldY = this.y;
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Check collisions with all objects
                gameState.objects.forEach(obj => {
                    if (this.checkCollisionWithObject(obj)) {
                        this.resolveCollision(obj, oldX, oldY);
                    }
                });
                
                // Boundary collisions
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = Math.abs(this.vx) * 0.8;
                    this.playBounceSound();
                }
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx = -Math.abs(this.vx) * 0.8;
                    this.playBounceSound();
                }
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy = Math.abs(this.vy) * 0.8;
                    this.playBounceSound();
                }
                
                // Update trail
                this.trail.push({ x: this.x, y: this.y, alpha: 1 });
                if (this.trail.length > 10) this.trail.shift();
                this.trail.forEach((point, index) => { point.alpha = index / this.trail.length; });
                
                // Remove if falls off screen
                if (this.y > canvas.height + 50) this.active = false;
            }
            
            checkCollisionWithObject(obj) {
                // Simple AABB vs Circle collision
                const closestX = Math.max(obj.x, Math.min(this.x, obj.x + obj.width));
                const closestY = Math.max(obj.y, Math.min(this.y, obj.y + obj.height));
                const dx = this.x - closestX;
                const dy = this.y - closestY;
                return (dx * dx + dy * dy) < (this.radius * this.radius);
            }
            
            resolveCollision(obj, oldX, oldY) {
                // Calculate collision normal
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                
                let normalX = this.x - centerX;
                let normalY = this.y - centerY;
                const length = Math.sqrt(normalX * normalX + normalY * normalY);
                
                if (length > 0) {
                    normalX /= length;
                    normalY /= length;
                } else {
                    normalX = 0; normalY = -1; // Default to up
                }
                
                // Move particle out of collision
                this.x = centerX + normalX * (obj.width/2 + this.radius + 2);
                this.y = centerY + normalY * (obj.height/2 + this.radius + 2);
                
                // Calculate reflection
                const elasticity = obj.type === 'bouncy-pad' ? 1.2 : 0.7;
                const dot = this.vx * normalX + this.vy * normalY;
                
                this.vx -= 2 * dot * normalX * elasticity;
                this.vy -= 2 * dot * normalY * elasticity;
                
                // Special behavior for ramps
                if (obj.type === 'ramp') {
                    const rampAngle = obj.rotation;
                    this.vx = Math.cos(rampAngle) * 120;
                    this.vy = Math.sin(rampAngle) * 120;
                }
                
                this.bounces++;
                this.playBounceSound();
            }
            
            playBounceSound() {
                const frequency = 200 + this.bounces * 50;
                playSound(frequency, 0.1, 'triangle', 0.4);
            }            
            render(ctx) {
                if (!this.active) return;
                this.trail.forEach((point, index) => {
                    ctx.save(); ctx.globalAlpha = point.alpha * 0.5; ctx.fillStyle = '#FFFF00'; ctx.shadowColor = '#FFFF00'; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.arc(point.x, point.y, this.radius * (index / this.trail.length), 0, Math.PI * 2); ctx.fill(); ctx.restore();
                });
                ctx.save(); ctx.fillStyle = '#FFFF00'; ctx.shadowColor = '#FFFF00'; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
        }
        
        const levels = [
            { name: "TUTORIAL B√ÅSICO", objects: [{ type: 'ramp', x: 200, y: 300, width: 100, height: 50 }], launcher: { x: 50, y: 200 }, chamber: { x: 350, y: 350 }, hint: "Arrastra la rampa rosa para crear un camino desde el c√≠rculo amarillo al cuadro verde" },
            { name: "BOUNCY CASTLE", objects: [{ type: 'bouncy-pad', x: 150, y: 300, width: 60, height: 60 }, { type: 'block', x: 250, y: 250, width: 80, height: 30 }], launcher: { x: 50, y: 350 }, chamber: { x: 350, y: 200 }, hint: "Bounce off the pad!" },
            { name: "BLOCK PUZZLE", objects: [{ type: 'block', x: 150, y: 300, width: 80, height: 30 }, { type: 'block', x: 280, y: 250, width: 60, height: 40 }], launcher: { x: 50, y: 250 }, chamber: { x: 380, y: 350 }, hint: "Create a path with blocks!" }
        ];
        
        function loadLevel(levelNumber) {
            const level = levels[levelNumber - 1];
            if (!level) return;
            
            gameState.objects = []; gameState.particle = null; gameState.levelComplete = false;
            
            level.objects.forEach(objData => {
                const obj = new PhysicsObject(objData.type, objData.x, objData.y, objData.width, objData.height, objData);
                gameState.objects.push(obj);
            });
            
            gameState.particleLauncher = new PhysicsObject('launcher', level.launcher.x, level.launcher.y, 30, 30, { isStatic: true, draggable: false, color: '#FFFF00' });
            gameState.collectionChamber = new PhysicsObject('chamber', level.chamber.x, level.chamber.y, 50, 50, { isStatic: true, draggable: false, color: '#39FF14' });
            
            document.getElementById('levelDisplay').textContent = `LEVEL ${levelNumber}: ${level.name}`;
        }
        
        function launchParticle() {
            if (gameState.particle && gameState.particle.active) return;
            const launcher = gameState.particleLauncher;
            gameState.particle = new Particle(launcher.x + launcher.width/2, launcher.y + launcher.height/2);
            gameState.particle.vx = 100; gameState.particle.vy = -50;
            gameState.gameActive = true;
            gtag('event', 'particle_launched', { 'event_category': 'gameplay', 'level': gameState.currentLevel });
        }
        
        function resetLevel() { loadLevel(gameState.currentLevel); gameState.gameActive = false; }
        function nextLevel() { if (gameState.currentLevel < levels.length) { gameState.currentLevel++; loadLevel(gameState.currentLevel); } }
        function showTutorial() {
            const tutorial = `üß™ C√ìMO JUGAR NEON LAB:\n\n` +
                `1Ô∏è‚É£ ARRASTRA objetos con el dedo
2ufe0fu20e3 DOBLE TAP para ROTAR/mouse\n` +
                `2Ô∏è‚É£ CREA un camino para la part√≠cula\n` +
                `3Ô∏è‚É£ Presiona TEST para lanzar\n` +
                `4Ô∏è‚É£ GU√çA la part√≠cula al cuadro verde\n\n` +
                `üéØ OBJETOS:\n` +
                `üìê RAMPAS: Dirigen la part√≠cula\n` +
                `üü¶ BLOQUES: Crean obst√°culos\n` +
                `üü¢ BOUNCY: Hacen rebotar\n\n` +
                `üí° CONSEJO: ${levels[gameState.currentLevel - 1]?.hint || "Experimenta y divi√©rtete!"}`;
            alert(tutorial);
        }
        
        let isDragging = false;
        
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0] ? event.touches[0].clientX : 0);
            const clientY = event.clientY || (event.touches && event.touches[0] ? event.touches[0].clientY : 0);
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        
        function handleStart(event) {
            event.preventDefault();
            const mousePos = getMousePos(event);
            const currentTime = Date.now();
            
            for (let obj of gameState.objects) {
                if (obj.draggable && obj.contains(mousePos.x, mousePos.y)) {
                    // Check for double tap (rotation)
                    if (tapTarget === obj && currentTime - lastTapTime < 300) {
                        // DOUBLE TAP: Rotate object 45 degrees
                        obj.rotation += Math.PI / 4;
                        playSound(800, 0.1, 'square', 0.3); // Rotation sound
                        tapTarget = null;
                        lastTapTime = 0;
                        return;
                    }
                    
                    // Single tap: Start dragging
                    gameState.draggedObject = obj;
                    gameState.dragOffset = { x: mousePos.x - obj.x, y: mousePos.y - obj.y };
                    isDragging = true;
                    tapTarget = obj;
                    lastTapTime = currentTime;
                    break;
                }
            }        }
        
        function handleMove(event) {
            event.preventDefault(); if (!isDragging || !gameState.draggedObject) return;
            const mousePos = getMousePos(event);
            gameState.draggedObject.x = mousePos.x - gameState.dragOffset.x;
            gameState.draggedObject.y = mousePos.y - gameState.dragOffset.y;
            gameState.draggedObject.x = Math.max(0, Math.min(canvas.width - gameState.draggedObject.width, gameState.draggedObject.x));
            gameState.draggedObject.y = Math.max(0, Math.min(canvas.height - gameState.draggedObject.height, gameState.draggedObject.y));
        }
        
        function handleEnd(event) { event.preventDefault(); isDragging = false; gameState.draggedObject = null; }
        
        canvas.addEventListener('mousedown', handleStart); canvas.addEventListener('mousemove', handleMove); canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart, { passive: false }); canvas.addEventListener('touchmove', handleMove, { passive: false }); canvas.addEventListener('touchend', handleEnd, { passive: false });
        
        let lastTime = 0;
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000; lastTime = currentTime;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameState.particle) {
                gameState.particle.update(deltaTime);
                if (gameState.particle.active) {
                    const chamber = gameState.collectionChamber;
                    const dx = gameState.particle.x - (chamber.x + chamber.width/2);
                    const dy = gameState.particle.y - (chamber.y + chamber.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if (distance < chamber.width/2 + gameState.particle.radius) levelComplete();
                }
            }
            
            if (gameState.particleLauncher) gameState.particleLauncher.render(ctx);
            if (gameState.collectionChamber) gameState.collectionChamber.render(ctx);
            gameState.objects.forEach(obj => obj.render(ctx));
            if (gameState.particle) gameState.particle.render(ctx);
            
            // Render tutorial indicators for level 1
            if (gameState.currentLevel === 1) {
                // Arrow from launcher to chamber
                ctx.save();
                ctx.strokeStyle = "#FFFF00";
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(gameState.particleLauncher.x + 30, gameState.particleLauncher.y + 15);
                ctx.lineTo(gameState.collectionChamber.x, gameState.collectionChamber.y + 25);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.fillStyle = "#FFFF00";
                ctx.font = "bold 14px Orbitron";
                ctx.textAlign = "center";
                ctx.fillText("INICIO", gameState.particleLauncher.x + 15, gameState.particleLauncher.y - 10);
                ctx.fillText("META", gameState.collectionChamber.x + 25, gameState.collectionChamber.y - 10);
                
                // Instructions on draggable objects
                gameState.objects.forEach(obj => {
                    if (obj.draggable) {
                        ctx.fillStyle = "#FF0080";
                        ctx.font = "bold 12px Orbitron";
                        ctx.fillText("ARRASTRA", obj.x + obj.width/2, obj.y - 15);
                    }
                });
                
                ctx.restore();
            }            
            requestAnimationFrame(gameLoop);
        }
        
        function levelComplete() {
            gameState.levelComplete = true; gameState.gameActive = false;
            const chamber = gameState.collectionChamber; const explosion = document.createElement('div');
            explosion.className = 'success-explosion';
            explosion.style.left = (chamber.x + chamber.width/2 - 50) + 'px';
            explosion.style.top = (chamber.y + chamber.height/2 - 50) + 'px';
            document.querySelector('.lab-area').appendChild(explosion);
            setTimeout(() => explosion.remove(), 600);
            gtag('event', 'level_completed', { 'event_category': 'gameplay', 'level': gameState.currentLevel });
            setTimeout(() => {
                if (gameState.currentLevel < levels.length) nextLevel();
                else alert('üéâ ¬°Felicidades! ¬°Has completado todos los experimentos!');
            }, 1500);
        }
        
        window.addEventListener('load', () => { resizeCanvas(); loadLevel(1); gameLoop(0); });
        window.addEventListener('resize', resizeCanvas);
    </script>
    
    <!-- AdSense Bottom -->
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-4129506161314540" data-ad-slot="auto" data-ad-format="auto"></ins>
    <script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</body>
</html>
