<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <title>Neon Lab - Physics Puzzle</title>
    
    <!-- PWA Icons -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Ccircle cx='16' cy='16' r='16' fill='%23FF0080'/%3E%3Cpath d='M8 8h16v8H8z' fill='%23FFFF00' stroke='%23FFFFFF'/%3E%3Ccircle cx='12' cy='24' r='3' fill='%2339FF14'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect width='180' height='180' rx='40' fill='%23FF0080'/%3E%3Cpath d='M40 40h40v40H40z' fill='%23FFFF00' stroke='%23FFFFFF' stroke-width='3'/%3E%3Ccircle cx='60' cy='120' r='12' fill='%2339FF14'/%3E%3Ctext x='90' y='110' font-family='monospace' font-size='24' fill='%2300FFFF'%3ELAB%3C/text%3E%3C/svg%3E">
    <meta name="theme-color" content="#FF0080">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: monospace;
            background: linear-gradient(135deg, #000 0%, #111 100%);
            color: #00FFFF;
            overflow-x: hidden;
            user-select: none;
            touch-action: manipulation;
        }
        .header {
            height: 50px;
            background: rgba(0,0,0,0.9);
            border-bottom: 2px solid #00FFFF;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 15px;
        }
        .title { font-size: 1.5rem; font-weight: bold; color: #39FF14; }
        .level-info { font-size: 0.9rem; }
        
        .instructions {
            background: rgba(0,0,0,0.8);
            color: #00FFFF;
            padding: 8px;
            text-align: center;
            font-size: 11px;
        }
        
        .game-area {
            height: calc(100vh - 140px);
            display: flex;
            justify-content: center;
            align-items: center;
            background: 
                linear-gradient(90deg, transparent 49%, rgba(0, 255, 255, 0.05) 50%, transparent 51%),
                linear-gradient(0deg, transparent 49%, rgba(0, 255, 255, 0.05) 50%, transparent 51%);
            background-size: 20px 20px;
        }
        
        canvas {
            border: 2px solid #FF0080;
            box-shadow: 0 0 15px rgba(255, 0, 128, 0.3);
            background: rgba(0, 0, 0, 0.3);
            touch-action: none;
        }
        
        .controls {
            height: 80px;
            background: rgba(0,0,0,0.9);
            border-top: 2px solid #00FFFF;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 8px;
        }
        
        button {
            background: #FF0080;
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 4px;
            cursor: pointer;
            font-family: monospace;
            font-size: 11px;
            font-weight: bold;
        }
        button.secondary { background: #00FFFF; color: #000; }
        button.tertiary { background: #666; }
        button:active { transform: scale(0.95); }
        
        @media (max-width: 768px) {
            canvas {
                width: 95vw !important;
                height: auto !important;
                max-width: 350px;
                max-height: 60vh;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">ÔøΩÔøΩ NEON LAB</div>
        <div class="level-info" id="levelDisplay">LEVEL 1</div>
    </div>
    
    <div class="instructions">
        üéØ ARRASTRA objetos, DOBLE TAP para rotar, presiona TEST
    </div>
    
    <div class="game-area">
        <canvas id="gameCanvas" width="350" height="500"></canvas>
    </div>
    
    <div class="controls">
        <button onclick="resetLevel()">üîÑ RESET</button>
        <button onclick="launchParticle()">üöÄ TEST</button>
        <button class="secondary" onclick="nextLevel()">‚û°Ô∏è NEXT</button>
        <button class="tertiary" onclick="showHelp()">‚ùì HELP</button>
    </div>

    <script>
        console.log("üß™ NEON LAB - FIXED VERSION");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = {
            currentLevel: 1,
            objects: [],
            particle: null,
            launcher: null,
            chamber: null,
            draggedObject: null,
            dragOffset: { x: 0, y: 0 }
        };
        
        let isDragging = false;
        let lastTapTime = 0;
        let tapTarget = null;
        let lastTime = 0;
        
        // Responsive canvas
        function resizeCanvas() {
            if (window.innerWidth < 768) {
                const maxWidth = Math.min(350, window.innerWidth - 20);
                const maxHeight = Math.min(500, window.innerHeight * 0.6);
                canvas.width = maxWidth;
                canvas.height = maxHeight;
            } else {
                canvas.width = 350;
                canvas.height = 500;
            }
        }
        
        class GameObject {
            constructor(type, x, y, width, height, color) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.rotation = 0;
                this.draggable = type !== 'launcher' && type !== 'chamber';
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 8;
                
                if (this.type === 'ramp') {
                    // Triangle
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, this.height/2);
                    ctx.lineTo(this.width/2, this.height/2);
                    ctx.lineTo(this.width/2, -this.height/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'bouncy-pad') {
                    // Circle
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // Rectangle
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                }
                
                ctx.restore();
            }
            
            contains(x, y) {
                return x >= this.x && x <= this.x + this.width && 
                       y >= this.y && y <= this.y + this.height;
            }
        }
        
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 120;
                this.vy = -80;
                this.radius = 5;
                this.active = true;
                this.trail = [];
                this.bounces = 0;
            }
            
            update(deltaTime) {
                if (!this.active) return;
                
                // Gravity
                this.vy += 350 * deltaTime;
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Check collisions
                for (let obj of gameState.objects) {
                    if (this.collidesWith(obj)) {
                        this.handleCollision(obj);
                        break;
                    }
                }
                
                // Boundary collisions
                if (this.x <= this.radius || this.x >= canvas.width - this.radius) {
                    this.vx = -this.vx * 0.8;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                if (this.y <= this.radius) {
                    this.vy = Math.abs(this.vy) * 0.8;
                    this.y = this.radius;
                }
                
                // Update trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 6) this.trail.shift();
                
                // Deactivate if falls off screen
                if (this.y > canvas.height + 100) this.active = false;
            }
            
            collidesWith(obj) {
                // Circle vs Rectangle collision
                const closestX = Math.max(obj.x, Math.min(this.x, obj.x + obj.width));
                const closestY = Math.max(obj.y, Math.min(this.y, obj.y + obj.height));
                
                const dx = this.x - closestX;
                const dy = this.y - closestY;
                
                return (dx * dx + dy * dy) < (this.radius * this.radius);
            }
            
            handleCollision(obj) {
                // Calculate collision normal
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                
                let normalX = this.x - centerX;
                let normalY = this.y - centerY;
                const length = Math.sqrt(normalX * normalX + normalY * normalY);
                
                if (length > 0) {
                    normalX /= length;
                    normalY /= length;
                }
                
                // Push particle out
                this.x = centerX + normalX * (obj.width/2 + this.radius + 1);
                this.y = centerY + normalY * (obj.height/2 + this.radius + 1);
                
                // Bounce
                const elasticity = obj.type === 'bouncy-pad' ? 1.3 : 0.75;
                const dot = this.vx * normalX + this.vy * normalY;
                
                this.vx -= 2 * dot * normalX * elasticity;
                this.vy -= 2 * dot * normalY * elasticity;
                
                // Ramp behavior
                if (obj.type === 'ramp') {
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const angle = obj.rotation - Math.PI/4;
                    this.vx = Math.cos(angle) * speed * 0.9;
                    this.vy = Math.sin(angle) * speed * 0.9;
                }
                
                this.bounces++;
            }
            
            render(ctx) {
                if (!this.active) return;
                
                // Trail
                this.trail.forEach((point, index) => {
                    ctx.save();
                    ctx.globalAlpha = (index + 1) / this.trail.length * 0.6;
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.radius * ((index + 1) / this.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                // Main particle
                ctx.save();
                ctx.fillStyle = '#FFFF00';
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        const levels = [
            {
                name: "TUTORIAL",
                objects: [
                    { type: 'ramp', x: 130, y: 250, width: 70, height: 35, color: '#FF0080' }
                ],
                launcher: { x: 50, y: 100 },
                chamber: { x: 250, y: 420 }
            },
            {
                name: "BOUNCY",
                objects: [
                    { type: 'bouncy-pad', x: 100, y: 200, width: 40, height: 40, color: '#39FF14' },
                    { type: 'block', x: 200, y: 300, width: 60, height: 20, color: '#00FFFF' }
                ],
                launcher: { x: 30, y: 50 },
                chamber: { x: 270, y: 450 }
            }
        ];
        
        function loadLevel(levelNumber) {
            const level = levels[levelNumber - 1];
            if (!level) return;
            
            gameState.objects = [];
            gameState.particle = null;
            
            // Scale for canvas size
            const scaleX = canvas.width / 350;
            const scaleY = canvas.height / 500;
            
            level.objects.forEach(objData => {
                gameState.objects.push(new GameObject(
                    objData.type,
                    objData.x * scaleX,
                    objData.y * scaleY,
                    objData.width * scaleX,
                    objData.height * scaleY,
                    objData.color
                ));
            });
            
            gameState.launcher = new GameObject(
                'launcher',
                level.launcher.x * scaleX,
                level.launcher.y * scaleY,
                20 * scaleX,
                20 * scaleY,
                '#FFFF00'
            );
            
            gameState.chamber = new GameObject(
                'chamber',
                level.chamber.x * scaleX,
                level.chamber.y * scaleY,
                30 * scaleX,
                30 * scaleY,
                '#39FF14'
            );
            
            document.getElementById('levelDisplay').textContent = `LEVEL ${levelNumber}: ${level.name}`;
        }
        
        function launchParticle() {
            if (gameState.particle && gameState.particle.active) return;
            
            gameState.particle = new Particle(
                gameState.launcher.x + gameState.launcher.width/2,
                gameState.launcher.y + gameState.launcher.height/2
            );
        }
        
        function resetLevel() { loadLevel(gameState.currentLevel); }
        function nextLevel() {
            if (gameState.currentLevel < levels.length) {
                gameState.currentLevel++;
                loadLevel(gameState.currentLevel);
            }
        }
        function showHelp() {
            alert(`üß™ NEON LAB HELP:
            
‚Ä¢ DRAG objects to move
‚Ä¢ DOUBLE TAP to rotate  
‚Ä¢ TEST to launch particle
‚Ä¢ Guide to green target

Objects:
üìê Ramps redirect particle
üü¶ Blocks are obstacles
üü¢ Bouncy pads boost`);
        }
        
        // Touch/Mouse handling
        function getPos(event) {
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX || event.touches[0].clientX) - rect.left;
            const y = (event.clientY || event.touches[0].clientY) - rect.top;
            return {
                x: x * (canvas.width / rect.width),
                y: y * (canvas.height / rect.height)
            };
        }
        
        function handleStart(event) {
            event.preventDefault();
            const pos = getPos(event);
            const now = Date.now();
            
            for (let obj of gameState.objects) {
                if (obj.draggable && obj.contains(pos.x, pos.y)) {
                    if (tapTarget === obj && now - lastTapTime < 300) {
                        obj.rotation += Math.PI / 4;
                        return;
                    }
                    
                    gameState.draggedObject = obj;
                    gameState.dragOffset = { x: pos.x - obj.x, y: pos.y - obj.y };
                    isDragging = true;
                    tapTarget = obj;
                    lastTapTime = now;
                    break;
                }
            }
        }
        
        function handleMove(event) {
            if (!isDragging) return;
            event.preventDefault();
            
            const pos = getPos(event);
            gameState.draggedObject.x = pos.x - gameState.dragOffset.x;
            gameState.draggedObject.y = pos.y - gameState.dragOffset.y;
            
            // Keep in bounds
            gameState.draggedObject.x = Math.max(0, Math.min(canvas.width - gameState.draggedObject.width, gameState.draggedObject.x));
            gameState.draggedObject.y = Math.max(0, Math.min(canvas.height - gameState.draggedObject.height, gameState.draggedObject.y));
        }
        
        function handleEnd(event) {
            event.preventDefault();
            isDragging = false;
            gameState.draggedObject = null;
        }
        
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        
        function gameLoop(time) {
            const deltaTime = Math.min((time - lastTime) / 1000, 0.016);
            lastTime = time;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update particle
            if (gameState.particle) {
                gameState.particle.update(deltaTime);
                
                // Win check
                if (gameState.particle.active) {
                    const dx = gameState.particle.x - (gameState.chamber.x + gameState.chamber.width/2);
                    const dy = gameState.particle.y - (gameState.chamber.y + gameState.chamber.height/2);
                    if (Math.sqrt(dx*dx + dy*dy) < 20) {
                        gameState.particle.active = false;
                        setTimeout(() => alert("üéâ Level Complete!"), 300);
                    }
                }
            }
            
            // Render
            gameState.launcher.render(ctx);
            gameState.chamber.render(ctx);
            gameState.objects.forEach(obj => obj.render(ctx));
            if (gameState.particle) gameState.particle.render(ctx);
            
            // Tutorial arrow
            if (gameState.currentLevel === 1 && !gameState.particle) {
                ctx.save();
                ctx.strokeStyle = "#FFFF00";
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(gameState.launcher.x + 15, gameState.launcher.y + 15);
                ctx.lineTo(gameState.chamber.x + 15, gameState.chamber.y);
                ctx.stroke();
                ctx.restore();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        window.addEventListener('load', () => {
            resizeCanvas();
            loadLevel(1);
            requestAnimationFrame(gameLoop);
            
            window.addEventListener('resize', () => {
                resizeCanvas();
                loadLevel(gameState.currentLevel);
            });
        });
    </script>
</body>
</html>
