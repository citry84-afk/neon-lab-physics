<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Lab - Physics Puzzle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: monospace;
            background: #000;
            color: #00FFFF;
            overflow: hidden;
        }
        canvas {
            max-width: 100vw;
            max-height: 60vh;
            width: auto;
            height: auto;            display: block;
            margin: 20px auto;
            border: 2px solid #FF0080;
            background: #111;
        }
        .controls {
            text-align: center;
            padding: 20px;
        }
        button {
            background: #FF0080;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
        }
        .info {
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.8);
            color: #00FFFF;
        }
        @media (max-width: 768px) {
            body { font-size: 14px; }
            .info h1 { font-size: 1.5rem; }
            .controls { padding: 10px; }
            button { padding: 8px 15px; font-size: 12px; margin: 3px; }
            canvas { 
                width: 95vw !important;
                height: 60vh !important;
                max-width: 400px;
                max-height: 600px;
            }
        }
        @media (orientation: portrait) {
            canvas {
                width: 90vw !important;
                height: 65vh !important;
            }
        }    </style>
</head>
<body>
    <div class="info">
        <h1>üß™ NEON LAB - PHYSICS PUZZLE</h1>
        <div id="levelDisplay">LEVEL 1: TUTORIAL</div>
        <p>ARRASTRA objetos, DOBLE TAP para rotar, presiona TEST</p>
    </div>
    
    <canvas id="gameCanvas" width="400" height="700"></canvas>
    
    <div class="controls">
        <button onclick="resetLevel()">üîÑ RESET</button>
        <button onclick="launchParticle()">üöÄ TEST</button>
        <button onclick="nextLevel()">‚û°Ô∏è NEXT</button>
        <button onclick="showHelp()">‚ùì HELP</button>
    </div>

    <script>
        console.log("üß™ NEON LAB STARTING...");
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = {
            currentLevel: 1,
            objects: [],
            particle: null,
            launcher: null,
            chamber: null,
            draggedObject: null,
            dragOffset: { x: 0, y: 0 }
        };
        
        let isDragging = false;
        let lastTime = 0;
        
        class GameObject {
            constructor(type, x, y, width, height, color = '#FF0080') {
                this.type = type;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.rotation = 0;
                this.draggable = type !== 'launcher' && type !== 'chamber';
            }
            
            render(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(this.rotation);
                
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                if (this.type === 'ramp') {
                    ctx.beginPath();
                    ctx.moveTo(-this.width/2, this.height/2);
                    ctx.lineTo(this.width/2, this.height/2);
                    ctx.lineTo(this.width/2, -this.height/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.type === 'launcher' || this.type === 'bouncy-pad') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                    ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);
                }
                
                ctx.restore();
            }
            
            contains(x, y) {
                return x >= this.x && x <= this.x + this.width && 
                       y >= this.y && y <= this.y + this.height;
            }
        }
        
        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 120;
                this.vy = -80;
                this.radius = 8;
                this.active = true;
                this.trail = [];
            }
            
            update(deltaTime) {
                if (!this.active) return;
                
                // Gravity
                this.vy += 300 * deltaTime;
                
                // Update position
                this.x += this.vx * deltaTime;
                this.y += this.vy * deltaTime;
                
                // Check collisions with objects
                gameState.objects.forEach(obj => {
                    if (this.checkCollision(obj)) {
                        this.bounce(obj);
                    }
                });
                
                // Boundary collisions
                if (this.x < this.radius || this.x > canvas.width - this.radius) {
                    this.vx = -this.vx * 0.8;
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x));
                }
                if (this.y < this.radius) {
                    this.vy = Math.abs(this.vy) * 0.8;
                    this.y = this.radius;
                }
                
                // Update trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 10) this.trail.shift();
                
                // Deactivate if falls off screen
                if (this.y > canvas.height + 100) this.active = false;
            }
            
            checkCollision(obj) {
                const closestX = Math.max(obj.x, Math.min(this.x, obj.x + obj.width));
                const closestY = Math.max(obj.y, Math.min(this.y, obj.y + obj.height));
                const dx = this.x - closestX;
                const dy = this.y - closestY;
                return (dx * dx + dy * dy) < (this.radius * this.radius);
            }
            
            bounce(obj) {
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                
                let normalX = this.x - centerX;
                let normalY = this.y - centerY;
                const length = Math.sqrt(normalX * normalX + normalY * normalY);
                
                if (length > 0) {
                    normalX /= length;
                    normalY /= length;
                }
                
                // Move out of collision
                this.x = centerX + normalX * (obj.width/2 + this.radius + 2);
                this.y = centerY + normalY * (obj.height/2 + this.radius + 2);
                
                // Reflect velocity
                const elasticity = obj.type === 'bouncy-pad' ? 1.3 : 0.7;
                const dot = this.vx * normalX + this.vy * normalY;
                
                this.vx -= 2 * dot * normalX * elasticity;
                this.vy -= 2 * dot * normalY * elasticity;
                
                // Special ramp behavior
                if (obj.type === 'ramp') {
                    this.vx = Math.cos(obj.rotation) * 150;
                    this.vy = Math.sin(obj.rotation) * 150;
                }
            }
            
            render(ctx) {
                if (!this.active) return;
                
                // Render trail
                this.trail.forEach((point, index) => {
                    ctx.save();
                    ctx.globalAlpha = index / this.trail.length * 0.5;
                    ctx.fillStyle = '#FFFF00';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.radius * (index / this.trail.length), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                // Render particle
                ctx.save();
                ctx.fillStyle = '#FFFF00';
                ctx.shadowColor = '#FFFF00';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }
        
        const levels = [
            {
                name: "TUTORIAL",
                objects: [
                    { type: 'ramp', x: 200, y: 300, width: 100, height: 50, color: '#FF0080' }
                ],
                launcher: { x: 50, y: 100 },
                chamber: { x: 300, y: 600 }
            },
            {
                name: "BOUNCY",
                objects: [
                    { type: 'bouncy-pad', x: 100, y: 250, width: 50, height: 50, color: '#39FF14' },
                    { type: 'block', x: 200, y: 400, width: 70, height: 25, color: '#00FFFF' }
                ],
                launcher: { x: 50, y: 50 },
                chamber: { x: 300, y: 550 }
            }
        ];
        
        function loadLevel(levelNumber) {
            console.log(`Loading level ${levelNumber}...`);
            
            const level = levels[levelNumber - 1];
            if (!level) return;
            
            gameState.objects = [];
            gameState.particle = null;
            
            // Create level objects
            level.objects.forEach(objData => {
                const obj = new GameObject(
                    objData.type,
                    objData.x,
                    objData.y,
                    objData.width,
                    objData.height,
                    objData.color
                );
                gameState.objects.push(obj);
            });
            
            // Create launcher and chamber
            gameState.launcher = new GameObject(
                'launcher',
                level.launcher.x,
                level.launcher.y,
                30,
                30,
                '#FFFF00'
            );
            
            gameState.chamber = new GameObject(
                'chamber',
                level.chamber.x,
                level.chamber.y,
                50,
                50,
                '#39FF14'
            );
            
            document.getElementById('levelDisplay').textContent = `LEVEL ${levelNumber}: ${level.name}`;
            console.log(`Level loaded: ${gameState.objects.length} objects`);
        }
        
        function launchParticle() {
            if (gameState.particle && gameState.particle.active) return;
            
            gameState.particle = new Particle(
                gameState.launcher.x + 15,
                gameState.launcher.y + 15
            );
            
            console.log("Particle launched!");
        }
        
        function resetLevel() {
            loadLevel(gameState.currentLevel);
        }
        
        function nextLevel() {
            if (gameState.currentLevel < levels.length) {
                gameState.currentLevel++;
                loadLevel(gameState.currentLevel);
            }
        }
        
        function showHelp() {
            alert(`üß™ NEON LAB HELP:
            
1. DRAG objects to move them
2. DOUBLE CLICK to rotate objects  
3. Click TEST to launch particle
4. Guide particle to green chamber

OBJECTS:
- Pink triangles: Ramps
- Blue squares: Blocks  
- Green circles: Bouncy pads`);
        }
        
        // Event handling
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }
        
        let lastClickTime = 0;
        let lastClickTarget = null;
        
        function handleMouseDown(event) {
            event.preventDefault();
            const mousePos = getMousePos(event);
            const currentTime = Date.now();
            
            for (let obj of gameState.objects) {
                if (obj.draggable && obj.contains(mousePos.x, mousePos.y)) {
                    // Check for double click (rotation)
                    if (lastClickTarget === obj && currentTime - lastClickTime < 300) {
                        obj.rotation += Math.PI / 4;
                        console.log("Object rotated");
                        return;
                    }
                    
                    // Start dragging
                    gameState.draggedObject = obj;
                    gameState.dragOffset = {
                        x: mousePos.x - obj.x,
                        y: mousePos.y - obj.y
                    };
                    isDragging = true;
                    lastClickTarget = obj;
                    lastClickTime = currentTime;
                    break;
                }
            }
        }
        
        function handleMouseMove(event) {
            if (!isDragging || !gameState.draggedObject) return;
            
            event.preventDefault();
            const mousePos = getMousePos(event);
            
            gameState.draggedObject.x = mousePos.x - gameState.dragOffset.x;
            gameState.draggedObject.y = mousePos.y - gameState.dragOffset.y;
            
            // Keep object within canvas
            gameState.draggedObject.x = Math.max(0, Math.min(canvas.width - gameState.draggedObject.width, gameState.draggedObject.x));
            gameState.draggedObject.y = Math.max(0, Math.min(canvas.height - gameState.draggedObject.height, gameState.draggedObject.y));
        }
        
        function handleMouseUp(event) {
            event.preventDefault();
            isDragging = false;
            gameState.draggedObject = null;
        }
        
        // Add event listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchstart', handleMouseDown);
        canvas.addEventListener('touchmove', handleMouseMove);
        canvas.addEventListener('touchend', handleMouseUp);
        
        // Game loop
        function gameLoop(currentTime) {
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update particle
            if (gameState.particle) {
                gameState.particle.update(deltaTime);
                
                // Check win condition
                if (gameState.particle.active && gameState.chamber) {
                    const dx = gameState.particle.x - (gameState.chamber.x + gameState.chamber.width/2);
                    const dy = gameState.particle.y - (gameState.chamber.y + gameState.chamber.height/2);
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < 30) {
                        console.log("Level completed!");
                        alert("üéâ Level Completed!");
                        gameState.particle.active = false;
                    }
                }
            }
            
            // Render everything
            if (gameState.launcher) gameState.launcher.render(ctx);
            if (gameState.chamber) gameState.chamber.render(ctx);
            gameState.objects.forEach(obj => obj.render(ctx));
            if (gameState.particle) gameState.particle.render(ctx);
            
            // Tutorial indicators for level 1
            if (gameState.currentLevel === 1) {
                ctx.save();
                ctx.strokeStyle = "#FFFF00";
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(gameState.launcher.x + 30, gameState.launcher.y + 15);
                ctx.lineTo(gameState.chamber.x, gameState.chamber.y + 25);
                ctx.stroke();
                
                ctx.fillStyle = "#FFFF00";
                ctx.font = "12px monospace";
                ctx.fillText("START", gameState.launcher.x, gameState.launcher.y - 10);
                ctx.fillText("GOAL", gameState.chamber.x, gameState.chamber.y - 10);
                
                ctx.restore();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize
        window.addEventListener('load', () => {
            console.log("üöÄ Initializing Neon Lab...");
            
            // Responsive canvas sizing
            function resizeCanvas() {
                const container = canvas.parentElement;
                const maxWidth = Math.min(400, window.innerWidth * 0.95);
                const maxHeight = Math.min(700, window.innerHeight * 0.6);
                
                // Keep aspect ratio for vertical layout
                if (window.innerWidth < 768 || window.orientation === 0) {
                    canvas.width = maxWidth;
                    canvas.height = maxHeight;
                } else {
                    canvas.width = 400;
                    canvas.height = 700;
                }
                
                console.log(`Canvas resized to: ${canvas.width}x${canvas.height}`);
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('orientationchange', () => {
                setTimeout(resizeCanvas, 100);
            });
            
            loadLevel(1);
            requestAnimationFrame(gameLoop);
            console.log("‚úÖ Neon Lab ready!");
        });    </script>
</body>
</html>
